"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeSts = void 0;
const nock = require("nock");
const uuid = require("uuid");
const xmlJs = require("xml-js");
/**
 * Class for mocking AWS HTTP Requests and pretending to be STS
 *
 * This is necessary for testing our authentication layer. Most other mocking
 * libraries don't consider as they mock functional methods which happen BEFORE
 * the SDK's HTTP/Authentication layer.
 *
 * Instead, we want to validate how we're setting up credentials for the
 * SDK, so we pretend to be the STS server and have an in-memory database
 * of users and roles.
 */
class FakeSts {
    constructor() {
        this.assumedRoles = new Array();
        this.identities = {};
        this.roles = {};
    }
    /**
     * Begin mocking
     */
    begin() {
        const self = this;
        nock.disableNetConnect();
        if (!nock.isActive()) {
            nock.activate();
        }
        nock(/.*/).persist().post(/.*/).reply(function (uri, body, cb) {
            const parsedBody = typeof body === 'string' ? urldecode(body) : body;
            try {
                const response = self.handleRequest({
                    uri,
                    host: this.req.headers.host,
                    parsedBody,
                    headers: this.req.headers,
                });
                cb(null, [200, xmlJs.js2xml(response, { compact: true })]);
            }
            catch (e) {
                cb(null, [400, xmlJs.js2xml({
                        ErrorResponse: {
                            _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                            Error: {
                                Type: 'Sender',
                                Code: e.code ?? 'Error',
                                Message: e.message,
                            },
                            RequestId: '1',
                        },
                    }, { compact: true })]);
            }
        });
        // Scrub some environment variables that might be set if we're running on CodeBuild which will interfere with the tests.
        delete process.env.AWS_PROFILE;
        delete process.env.AWS_REGION;
        delete process.env.AWS_DEFAULT_REGION;
        delete process.env.AWS_ACCESS_KEY_ID;
        delete process.env.AWS_SECRET_ACCESS_KEY;
        delete process.env.AWS_SESSION_TOKEN;
    }
    /**
     * Restore everything to normal
     */
    restore() {
        nock.restore(); // https://github.com/nock/nock/issues/1817
        nock.cleanAll();
        nock.enableNetConnect();
    }
    /**
     * Register a user
     */
    registerUser(account, accessKey, options = {}) {
        const userName = options.name ?? `User${Object.keys(this.identities).length + 1}`;
        this.identities[accessKey] = {
            account: account,
            arn: `arn:${options.partition ?? 'aws'}:sts::${account}:user/${userName}`,
            userId: `${accessKey}:${userName}`,
        };
    }
    /**
     * Register an assumable role
     */
    registerRole(account, roleArn, options = {}) {
        const roleName = options.name ?? `Role${Object.keys(this.roles).length + 1}`;
        this.roles[roleArn] = {
            allowedAccounts: options.allowedAccounts ?? [account],
            arn: roleArn,
            roleName,
            account,
        };
    }
    handleRequest(mockRequest) {
        const response = (() => {
            const identity = this.identity(mockRequest);
            switch (mockRequest.parsedBody.Action) {
                case 'GetCallerIdentity':
                    return this.handleGetCallerIdentity(identity);
                case 'AssumeRole':
                    return this.handleAssumeRole(identity, mockRequest);
            }
            throw new Error(`Unrecognized Action in MockAwsHttp: ${mockRequest.parsedBody.Action}`);
        })();
        // console.log(mockRequest.parsedBody, '->', response);
        return response;
    }
    handleGetCallerIdentity(identity) {
        return {
            GetCallerIdentityResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                GetCallerIdentityResult: {
                    Arn: identity.arn,
                    UserId: identity.userId,
                    Account: identity.account,
                },
                ResponseMetadata: {
                    RequestId: '1',
                },
            },
        };
    }
    handleAssumeRole(identity, mockRequest) {
        this.checkForFailure(mockRequest.parsedBody.RoleArn);
        this.assumedRoles.push({
            roleArn: mockRequest.parsedBody.RoleArn,
            roleSessionName: mockRequest.parsedBody.RoleSessionName,
            serialNumber: mockRequest.parsedBody.SerialNumber,
            tokenCode: mockRequest.parsedBody.TokenCode,
        });
        const roleArn = mockRequest.parsedBody.RoleArn;
        const targetRole = this.roles[roleArn];
        if (!targetRole) {
            throw new Error(`No such role: ${roleArn}`);
        }
        if (!targetRole.allowedAccounts.includes(identity.account)) {
            throw new Error(`Identity from account: ${identity.account} not allowed to assume ${roleArn}, must be one of: ${targetRole.allowedAccounts}`);
        }
        const freshAccessKey = uuid.v4();
        // Register a new "user" (identity) for this access key
        this.registerUser(targetRole.account, freshAccessKey, {
            name: `AssumedRole-${targetRole.roleName}-${identity.userId}`,
        });
        return {
            AssumeRoleResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                AssumeRoleResult: {
                    AssumedRoleUser: {
                        Arn: roleArn,
                        AssumedRoleId: `${freshAccessKey}:${targetRole.roleName}`,
                    },
                    Credentials: {
                        AccessKeyId: freshAccessKey,
                        SecretAccessKey: 'Secret',
                        SessionToken: 'Token',
                        Expiration: new Date(Date.now() + 3600 * 1000).toISOString(),
                    },
                    PackedPolicySize: 6,
                },
            },
            ResponseMetadata: {
                RequestId: '1',
            },
        };
    }
    checkForFailure(s) {
        const failureRequested = s.match(/<FAIL:([^>]+)>/);
        if (failureRequested) {
            const err = new Error(`STS failing by user request: ${failureRequested[1]}`);
            err.code = failureRequested[1];
            throw err;
        }
    }
    identity(mockRequest) {
        const keyId = this.accessKeyId(mockRequest);
        this.checkForFailure(keyId);
        const ret = this.identities[keyId];
        if (!ret) {
            throw new Error(`Unrecognized access key used: ${keyId}`);
        }
        return ret;
    }
    /**
     * Return the access key from a signed request
     */
    accessKeyId(mockRequest) {
        // "AWS4-HMAC-SHA256 Credential=(ab1a5e4c-ff41-4811-ac5f-6d1230f7aa90)access/20201210/eu-bla-5/sts/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=9b31011173a7842fa372d4ef7c431c08f0b1514fdaf54145560a4db7ecd24529"
        const auth = mockRequest.headers.authorization;
        const m = auth?.match(/Credential=([^\/]+)/);
        if (!m) {
            throw new Error(`No correct authorization header: ${auth}`);
        }
        return m[1];
    }
}
exports.FakeSts = FakeSts;
function urldecode(body) {
    const parts = body.split('&');
    const ret = {};
    for (const part of parts) {
        const [k, v] = part.split('=');
        ret[decodeURIComponent(k)] = decodeURIComponent(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFrZS1zdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmYWtlLXN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLGdDQUFnQztBQXNCaEM7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQWEsT0FBTztJQU1sQjtRQUxnQixpQkFBWSxHQUFHLElBQUksS0FBSyxFQUFlLENBQUM7UUFFaEQsZUFBVSxHQUF1QyxFQUFFLENBQUM7UUFDcEQsVUFBSyxHQUFtQyxFQUFFLENBQUM7SUFHbkQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSztRQUNWLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUVsQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNqQjtRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQWdCLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtZQUNqRSxNQUFNLFVBQVUsR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBRXJFLElBQUk7Z0JBQ0YsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztvQkFDbEMsR0FBRztvQkFDSCxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSTtvQkFDM0IsVUFBVTtvQkFDVixPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPO2lCQUMxQixDQUFDLENBQUM7Z0JBQ0gsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsTUFBTSxD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QUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sR0FBRyxHQUEyQixFQUFFLENBQUM7SUFDdkMsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7UUFDeEIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BEO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbm9jayBmcm9tICdub2NrJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgKiBhcyB4bWxKcyBmcm9tICd4bWwtanMnO1xuXG5pbnRlcmZhY2UgUmVnaXN0ZXJlZElkZW50aXR5IHtcbiAgcmVhZG9ubHkgYWNjb3VudDogc3RyaW5nO1xuICByZWFkb25seSBhcm46IHN0cmluZztcbiAgcmVhZG9ubHkgdXNlcklkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWdpc3RlcmVkUm9sZSB7XG4gIHJlYWRvbmx5IGFjY291bnQ6IHN0cmluZztcbiAgcmVhZG9ubHkgYWxsb3dlZEFjY291bnRzOiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgYXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJvbGVOYW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBc3N1bWVkUm9sZSB7XG4gIHJlYWRvbmx5IHJvbGVBcm46IHN0cmluZztcbiAgcmVhZG9ubHkgc2VyaWFsTnVtYmVyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRva2VuQ29kZTogc3RyaW5nO1xuICByZWFkb25seSByb2xlU2Vzc2lvbk5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgbW9ja2luZyBBV1MgSFRUUCBSZXF1ZXN0cyBhbmQgcHJldGVuZGluZyB0byBiZSBTVFNcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdGVzdGluZyBvdXIgYXV0aGVudGljYXRpb24gbGF5ZXIuIE1vc3Qgb3RoZXIgbW9ja2luZ1xuICogbGlicmFyaWVzIGRvbid0IGNvbnNpZGVyIGFzIHRoZXkgbW9jayBmdW5jdGlvbmFsIG1ldGhvZHMgd2hpY2ggaGFwcGVuIEJFRk9SRVxuICogdGhlIFNESydzIEhUVFAvQXV0aGVudGljYXRpb24gbGF5ZXIuXG4gKlxuICogSW5zdGVhZCwgd2Ugd2FudCB0byB2YWxpZGF0ZSBob3cgd2UncmUgc2V0dGluZyB1cCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiBTREssIHNvIHdlIHByZXRlbmQgdG8gYmUgdGhlIFNUUyBzZXJ2ZXIgYW5kIGhhdmUgYW4gaW4tbWVtb3J5IGRhdGFiYXNlXG4gKiBvZiB1c2VycyBhbmQgcm9sZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWtlU3RzIHtcbiAgcHVibGljIHJlYWRvbmx5IGFzc3VtZWRSb2xlcyA9IG5ldyBBcnJheTxBc3N1bWVkUm9sZT4oKTtcblxuICBwcml2YXRlIGlkZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIFJlZ2lzdGVyZWRJZGVudGl0eT4gPSB7fTtcbiAgcHJpdmF0ZSByb2xlczogUmVjb3JkPHN0cmluZywgUmVnaXN0ZXJlZFJvbGU+ID0ge307XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gbW9ja2luZ1xuICAgKi9cbiAgcHVibGljIGJlZ2luKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgbm9jay5kaXNhYmxlTmV0Q29ubmVjdCgpO1xuICAgIGlmICghbm9jay5pc0FjdGl2ZSgpKSB7XG4gICAgICBub2NrLmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIG5vY2soLy4qLykucGVyc2lzdCgpLnBvc3QoLy4qLykucmVwbHkoZnVuY3Rpb24gKHRoaXMsIHVyaSwgYm9keSwgY2IpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgPyB1cmxkZWNvZGUoYm9keSkgOiBib2R5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHNlbGYuaGFuZGxlUmVxdWVzdCh7XG4gICAgICAgICAgdXJpLFxuICAgICAgICAgIGhvc3Q6IHRoaXMucmVxLmhlYWRlcnMuaG9zdCxcbiAgICAgICAgICBwYXJzZWRCb2R5LFxuICAgICAgICAgIGhlYWRlcnM6IHRoaXMucmVxLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjYihudWxsLCBbMjAwLCB4bWxKcy5qczJ4bWwocmVzcG9uc2UsIHsgY29tcGFjdDogdHJ1ZSB9KV0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYihudWxsLCBbNDAwLCB4bWxKcy5qczJ4bWwoe1xuICAgICAgICAgIEVycm9yUmVzcG9uc2U6IHtcbiAgICAgICAgICAgIF9hdHRyaWJ1dGVzOiB7IHhtbG5zOiAnaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS8nIH0sXG4gICAgICAgICAgICBFcnJvcjoge1xuICAgICAgICAgICAgICBUeXBlOiAnU2VuZGVyJyxcbiAgICAgICAgICAgICAgQ29kZTogZS5jb2RlID8/ICdFcnJvcicsXG4gICAgICAgICAgICAgIE1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSZXF1ZXN0SWQ6ICcxJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LCB7IGNvbXBhY3Q6IHRydWUgfSldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNjcnViIHNvbWUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgbWlnaHQgYmUgc2V0IGlmIHdlJ3JlIHJ1bm5pbmcgb24gQ29kZUJ1aWxkIHdoaWNoIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRlc3RzLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfUFJPRklMRTtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTjtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRDtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BV1NfU0VTU0lPTl9UT0tFTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIGV2ZXJ5dGhpbmcgdG8gbm9ybWFsXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZSgpIHtcbiAgICBub2NrLnJlc3RvcmUoKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vY2svbm9jay9pc3N1ZXMvMTgxN1xuICAgIG5vY2suY2xlYW5BbGwoKTtcbiAgICBub2NrLmVuYWJsZU5ldENvbm5lY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHVzZXJcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclVzZXIoYWNjb3VudDogc3RyaW5nLCBhY2Nlc3NLZXk6IHN0cmluZywgb3B0aW9uczogUmVnaXN0ZXJVc2VyT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdXNlck5hbWUgPSBvcHRpb25zLm5hbWUgPz8gYFVzZXIke09iamVjdC5rZXlzKHRoaXMuaWRlbnRpdGllcykubGVuZ3RoICsgMSB9YDtcblxuICAgIHRoaXMuaWRlbnRpdGllc1thY2Nlc3NLZXldID0ge1xuICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgIGFybjogYGFybjoke29wdGlvbnMucGFydGl0aW9uID8/ICdhd3MnfTpzdHM6OiR7YWNjb3VudH06dXNlci8ke3VzZXJOYW1lfWAsXG4gICAgICB1c2VySWQ6IGAke2FjY2Vzc0tleX06JHt1c2VyTmFtZX1gLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gYXNzdW1hYmxlIHJvbGVcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclJvbGUoYWNjb3VudDogc3RyaW5nLCByb2xlQXJuOiBzdHJpbmcsIG9wdGlvbnM6IFJlZ2lzdGVyUm9sZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJvbGVOYW1lID0gb3B0aW9ucy5uYW1lID8/IGBSb2xlJHtPYmplY3Qua2V5cyh0aGlzLnJvbGVzKS5sZW5ndGggKyAxIH1gO1xuXG4gICAgdGhpcy5yb2xlc1tyb2xlQXJuXSA9IHtcbiAgICAgIGFsbG93ZWRBY2NvdW50czogb3B0aW9ucy5hbGxvd2VkQWNjb3VudHMgPz8gW2FjY291bnRdLFxuICAgICAgYXJuOiByb2xlQXJuLFxuICAgICAgcm9sZU5hbWUsXG4gICAgICBhY2NvdW50LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlcXVlc3QobW9ja1JlcXVlc3Q6IE1vY2tSZXF1ZXN0KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLmlkZW50aXR5KG1vY2tSZXF1ZXN0KTtcblxuICAgICAgc3dpdGNoIChtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LkFjdGlvbikge1xuICAgICAgICBjYXNlICdHZXRDYWxsZXJJZGVudGl0eSc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlR2V0Q2FsbGVySWRlbnRpdHkoaWRlbnRpdHkpO1xuXG4gICAgICAgIGNhc2UgJ0Fzc3VtZVJvbGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUFzc3VtZVJvbGUoaWRlbnRpdHksIG1vY2tSZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgQWN0aW9uIGluIE1vY2tBd3NIdHRwOiAke21vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuQWN0aW9ufWApO1xuICAgIH0pKCk7XG4gICAgLy8gY29uc29sZS5sb2cobW9ja1JlcXVlc3QucGFyc2VkQm9keSwgJy0+JywgcmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlR2V0Q2FsbGVySWRlbnRpdHkoaWRlbnRpdHk6IFJlZ2lzdGVyZWRJZGVudGl0eSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBHZXRDYWxsZXJJZGVudGl0eVJlc3BvbnNlOiB7XG4gICAgICAgIF9hdHRyaWJ1dGVzOiB7IHhtbG5zOiAnaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS8nIH0sXG4gICAgICAgIEdldENhbGxlcklkZW50aXR5UmVzdWx0OiB7XG4gICAgICAgICAgQXJuOiBpZGVudGl0eS5hcm4sXG4gICAgICAgICAgVXNlcklkOiBpZGVudGl0eS51c2VySWQsXG4gICAgICAgICAgQWNjb3VudDogaWRlbnRpdHkuYWNjb3VudCxcbiAgICAgICAgfSxcbiAgICAgICAgUmVzcG9uc2VNZXRhZGF0YToge1xuICAgICAgICAgIFJlcXVlc3RJZDogJzEnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVBc3N1bWVSb2xlKGlkZW50aXR5OiBSZWdpc3RlcmVkSWRlbnRpdHksIG1vY2tSZXF1ZXN0OiBNb2NrUmVxdWVzdCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHRoaXMuY2hlY2tGb3JGYWlsdXJlKG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuUm9sZUFybik7XG5cbiAgICB0aGlzLmFzc3VtZWRSb2xlcy5wdXNoKHtcbiAgICAgIHJvbGVBcm46IG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuUm9sZUFybixcbiAgICAgIHJvbGVTZXNzaW9uTmFtZTogbW9ja1JlcXVlc3QucGFyc2VkQm9keS5Sb2xlU2Vzc2lvbk5hbWUsXG4gICAgICBzZXJpYWxOdW1iZXI6IG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuU2VyaWFsTnVtYmVyLFxuICAgICAgdG9rZW5Db2RlOiBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlRva2VuQ29kZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJvbGVBcm4gPSBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlJvbGVBcm47XG4gICAgY29uc3QgdGFyZ2V0Um9sZSA9IHRoaXMucm9sZXNbcm9sZUFybl07XG4gICAgaWYgKCF0YXJnZXRSb2xlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggcm9sZTogJHtyb2xlQXJufWApO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0Um9sZS5hbGxvd2VkQWNjb3VudHMuaW5jbHVkZXMoaWRlbnRpdHkuYWNjb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSWRlbnRpdHkgZnJvbSBhY2NvdW50OiAke2lkZW50aXR5LmFjY291bnR9IG5vdCBhbGxvd2VkIHRvIGFzc3VtZSAke3JvbGVBcm59LCBtdXN0IGJlIG9uZSBvZjogJHt0YXJnZXRSb2xlLmFsbG93ZWRBY2NvdW50c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmVzaEFjY2Vzc0tleSA9IHV1aWQudjQoKTtcblxuICAgIC8vIFJlZ2lzdGVyIGEgbmV3IFwidXNlclwiIChpZGVudGl0eSkgZm9yIHRoaXMgYWNjZXNzIGtleVxuICAgIHRoaXMucmVnaXN0ZXJVc2VyKHRhcmdldFJvbGUuYWNjb3VudCwgZnJlc2hBY2Nlc3NLZXksIHtcbiAgICAgIG5hbWU6IGBBc3N1bWVkUm9sZS0ke3RhcmdldFJvbGUucm9sZU5hbWV9LSR7aWRlbnRpdHkudXNlcklkfWAsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgQXNzdW1lUm9sZVJlc3BvbnNlOiB7XG4gICAgICAgIF9hdHRyaWJ1dGVzOiB7IHhtbG5zOiAnaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS8nIH0sXG4gICAgICAgIEFzc3VtZVJvbGVSZXN1bHQ6IHtcbiAgICAgICAgICBBc3N1bWVkUm9sZVVzZXI6IHtcbiAgICAgICAgICAgIEFybjogcm9sZUFybixcbiAgICAgICAgICAgIEFzc3VtZWRSb2xlSWQ6IGAke2ZyZXNoQWNjZXNzS2V5fToke3RhcmdldFJvbGUucm9sZU5hbWV9YCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIENyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBBY2Nlc3NLZXlJZDogZnJlc2hBY2Nlc3NLZXksXG4gICAgICAgICAgICBTZWNyZXRBY2Nlc3NLZXk6ICdTZWNyZXQnLFxuICAgICAgICAgICAgU2Vzc2lvblRva2VuOiAnVG9rZW4nLFxuICAgICAgICAgICAgRXhwaXJhdGlvbjogbmV3IERhdGUoRGF0ZS5ub3coKSArIDM2MDAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgUGFja2VkUG9saWN5U2l6ZTogNixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBSZXNwb25zZU1ldGFkYXRhOiB7XG4gICAgICAgIFJlcXVlc3RJZDogJzEnLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZvckZhaWx1cmUoczogc3RyaW5nKSB7XG4gICAgY29uc3QgZmFpbHVyZVJlcXVlc3RlZCA9IHMubWF0Y2goLzxGQUlMOihbXj5dKyk+Lyk7XG4gICAgaWYgKGZhaWx1cmVSZXF1ZXN0ZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgU1RTIGZhaWxpbmcgYnkgdXNlciByZXF1ZXN0OiAke2ZhaWx1cmVSZXF1ZXN0ZWRbMV19YCk7XG4gICAgICAoZXJyIGFzIGFueSkuY29kZSA9IGZhaWx1cmVSZXF1ZXN0ZWRbMV07XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpZGVudGl0eShtb2NrUmVxdWVzdDogTW9ja1JlcXVlc3QpIHtcbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuYWNjZXNzS2V5SWQobW9ja1JlcXVlc3QpO1xuICAgIHRoaXMuY2hlY2tGb3JGYWlsdXJlKGtleUlkKTtcblxuICAgIGNvbnN0IHJldCA9IHRoaXMuaWRlbnRpdGllc1trZXlJZF07XG4gICAgaWYgKCFyZXQpIHsgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgYWNjZXNzIGtleSB1c2VkOiAke2tleUlkfWApOyB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFjY2VzcyBrZXkgZnJvbSBhIHNpZ25lZCByZXF1ZXN0XG4gICAqL1xuICBwcml2YXRlIGFjY2Vzc0tleUlkKG1vY2tSZXF1ZXN0OiBNb2NrUmVxdWVzdCk6IHN0cmluZyB7XG4gICAgLy8gXCJBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9KGFiMWE1ZTRjLWZmNDEtNDgxMS1hYzVmLTZkMTIzMGY3YWE5MClhY2Nlc3MvMjAyMDEyMTAvZXUtYmxhLTUvc3RzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGUsIFNpZ25hdHVyZT05YjMxMDExMTczYTc4NDJmYTM3MmQ0ZWY3YzQzMWMwOGYwYjE1MTRmZGFmNTQxNDU1NjBhNGRiN2VjZDI0NTI5XCJcbiAgICBjb25zdCBhdXRoID0gbW9ja1JlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuXG4gICAgY29uc3QgbSA9IGF1dGg/Lm1hdGNoKC9DcmVkZW50aWFsPShbXlxcL10rKS8pO1xuICAgIGlmICghbSkgeyB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvcnJlY3QgYXV0aG9yaXphdGlvbiBoZWFkZXI6ICR7YXV0aH1gKTsgfVxuICAgIHJldHVybiBtWzFdO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0ZXJVc2VyT3B0aW9ucyB7XG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBhcnRpdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlclJvbGVPcHRpb25zIHtcbiAgcmVhZG9ubHkgYWxsb3dlZEFjY291bnRzPzogc3RyaW5nW107XG4gIHJlYWRvbmx5IG5hbWU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBhcnRpdGlvbj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1vY2tSZXF1ZXN0IHtcbiAgcmVhZG9ubHkgaG9zdDogc3RyaW5nO1xuICByZWFkb25seSB1cmk6IHN0cmluZztcbiAgcmVhZG9ubHkgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgcmVhZG9ubHkgcGFyc2VkQm9keTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuZnVuY3Rpb24gdXJsZGVjb2RlKGJvZHk6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCBwYXJ0cyA9IGJvZHkuc3BsaXQoJyYnKTtcbiAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGNvbnN0IFtrLCB2XSA9IHBhcnQuc3BsaXQoJz0nKTtcbiAgICByZXRbZGVjb2RlVVJJQ29tcG9uZW50KGspXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19