"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const util = require("util");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const promptly = require("promptly");
const _env_1 = require("./_env");
const aws_sdk_inifile_1 = require("./aws-sdk-inifile");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * This is similar to the default credential provider chain created by the SDK
     * except:
     *
     * 1. Accepts profile argument in the constructor (the SDK must have it prepopulated
     *    in the environment).
     * 2. Conditionally checks EC2 credentials, because checking for EC2
     *    credentials on a non-EC2 machine may lead to long delays (in the best case)
     *    or an exception (in the worst case).
     * 3. Respects $AWS_SHARED_CREDENTIALS_FILE.
     * 4. Respects $AWS_DEFAULT_PROFILE in addition to $AWS_PROFILE.
     */
    static async credentialChain(options = {}) {
        // Force reading the `config` file if it exists by setting the appropriate
        // environment variable.
        await forceSdkToReadConfigIfPresent();
        // To match AWS CLI behavior, if a profile is explicitly given using --profile,
        // we use that to the exclusion of everything else (note: this does not apply
        // to AWS_PROFILE, environment credentials still take precedence over AWS_PROFILE)
        if (options.profile) {
            return new AWS.CredentialProviderChain(iniFileCredentialFactories(options.profile, options.httpOptions));
        }
        const implicitProfile = process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const sources = [
            () => new AWS.EnvironmentCredentials('AWS'),
            () => new AWS.EnvironmentCredentials('AMAZON'),
            ...iniFileCredentialFactories(implicitProfile, options.httpOptions),
        ];
        if (options.containerCreds ?? hasEcsCredentials()) {
            sources.push(() => new AWS.ECSCredentials());
        }
        else if (hasWebIdentityCredentials()) {
            // else if: we have found WebIdentityCredentials as provided by EKS ServiceAccounts
            sources.push(() => new AWS.TokenFileWebIdentityCredentials());
        }
        else if (options.ec2instance ?? await isEc2Instance()) {
            // else if: don't get EC2 creds if we should have gotten ECS or EKS creds
            // ECS and EKS instances also run on EC2 boxes but the creds represent something different.
            // Same behavior as upstream code.
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
        return new AWS.CredentialProviderChain(sources);
        function profileCredentials(profileName) {
            return new aws_sdk_inifile_1.PatchedSharedIniFileCredentials({
                profile: profileName,
                filename: credentialsFileName(),
                httpOptions: options.httpOptions,
                tokenCodeFn,
            });
        }
        function iniFileCredentialFactories(theProfile, theHttpOptions) {
            return [
                () => profileCredentials(theProfile),
                () => new AWS.SsoCredentials({
                    profile: theProfile,
                    httpOptions: theHttpOptions,
                }),
                () => new AWS.ProcessCredentials({ profile: theProfile }),
            ];
        }
    }
    /**
     * Return the default region in a CLI-compatible way
     *
     * Mostly copied from node_loader.js, but with the following differences to make it
     * AWS CLI compatible:
     *
     * 1. Takes a profile name as an argument (instead of forcing it to be taken from $AWS_PROFILE).
     *    This requires having made a copy of the SDK's `SharedIniFile` (the original
     *    does not take an argument).
     * 2. $AWS_DEFAULT_PROFILE and $AWS_DEFAULT_REGION are also respected.
     *
     * Lambda and CodeBuild set the $AWS_REGION variable.
     */
    static async region(options = {}) {
        const profile = options.profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        // Defaults inside constructor
        const toCheck = [
            { filename: credentialsFileName(), profile },
            { isConfig: true, filename: configFileName(), profile },
            { isConfig: true, filename: configFileName(), profile: 'default' },
        ];
        let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
        while (!region && toCheck.length > 0) {
            const opts = toCheck.shift();
            if (await fs.pathExists(opts.filename)) {
                const configFile = new sdk_ini_file_1.SharedIniFile(opts);
                const section = await configFile.getProfile(opts.profile);
                region = section?.region;
            }
        }
        if (!region && (options.ec2instance ?? await isEc2Instance())) {
            _env_1.debug('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
            const imdsOptions = {
                httpOptions: { timeout: 1000, connectTimeout: 1000 }, maxRetries: 2,
            };
            const metadataService = new AWS.MetadataService(imdsOptions);
            let token;
            try {
                token = await getImdsV2Token(metadataService);
            }
            catch (e) {
                _env_1.debug(`No IMDSv2 token: ${e}`);
            }
            try {
                region = await getRegionFromImds(metadataService, token);
                _env_1.debug(`AWS region from IMDS: ${region}`);
            }
            catch (e) {
                _env_1.debug(`Unable to retrieve AWS region from IMDS: ${e}`);
            }
        }
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            region = 'us-east-1'; // This is what the AWS CLI does
            _env_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${region}'`);
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether it looks like we'll have WebIdentityCredentials (that's what EKS uses) available
 * No check like hasEcsCredentials available, so have to implement our own.
 * @see https://github.com/aws/aws-sdk-js/blob/3ccfd94da07234ae87037f55c138392f38b6881d/lib/credentials/token_file_web_identity_credentials.js#L59
 */
function hasWebIdentityCredentials() {
    return Boolean(process.env.AWS_ROLE_ARN && process.env.AWS_WEB_IDENTITY_TOKEN_FILE);
}
/**
 * Return whether we're on an EC2 instance
 */
async function isEc2Instance() {
    if (isEc2InstanceCache === undefined) {
        _env_1.debug("Determining if we're on an EC2 instance.");
        let instance = false;
        if (process.platform === 'win32') {
            // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
            try {
                const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
                // output looks like
                //  UUID
                //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
                const lines = result.stdout.toString().split('\n');
                instance = lines.some(x => matchesRegex(/^ec2/i, x));
            }
            catch (e) {
                // Modern machines may not have wmic.exe installed. No reason to fail, just assume it's not an EC2 instance.
                _env_1.debug(`Checking using WMIC failed, assuming NOT an EC2 instance: ${e.message} (pass --ec2creds to force)`);
                instance = false;
            }
        }
        else {
            // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
            const files = [
                // This recognizes the Xen hypervisor based instances (pre-5th gen)
                ['/sys/hypervisor/uuid', /^ec2/i],
                // This recognizes the new Hypervisor (5th-gen instances and higher)
                // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
                // Instead, sys_vendor contains something like 'Amazon EC2'.
                ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
            ];
            for (const [file, re] of files) {
                if (matchesRegex(re, readIfPossible(file))) {
                    instance = true;
                    break;
                }
            }
        }
        _env_1.debug(instance ? 'Looks like an EC2 instance.' : 'Does not look like an EC2 instance.');
        isEc2InstanceCache = instance;
    }
    return isEc2InstanceCache;
}
let isEc2InstanceCache = undefined;
/**
 * Attempts to get a Instance Metadata Service V2 token
 */
async function getImdsV2Token(metadataService) {
    _env_1.debug('Attempting to retrieve an IMDSv2 token.');
    return new Promise((resolve, reject) => {
        metadataService.request('/latest/api/token', {
            method: 'PUT',
            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '60' },
        }, (err, token) => {
            if (err) {
                reject(err);
            }
            else if (!token) {
                reject(new Error('IMDS did not return a token.'));
            }
            else {
                resolve(token);
            }
        });
    });
}
/**
 * Attempts to get the region from the Instance Metadata Service
 */
async function getRegionFromImds(metadataService, token) {
    _env_1.debug('Retrieving the AWS region from the IMDS.');
    let options = {};
    if (token) {
        options = { headers: { 'x-aws-ec2-metadata-token': token } };
    }
    return new Promise((resolve, reject) => {
        metadataService.request('/latest/dynamic/instance-identity/document', options, (err, instanceIdentityDocument) => {
            if (err) {
                reject(err);
            }
            else if (!instanceIdentityDocument) {
                reject(new Error('IMDS did not return an Instance Identity Document.'));
            }
            else {
                try {
                    resolve(JSON.parse(instanceIdentityDocument).region);
                }
                catch (e) {
                    reject(e);
                }
            }
        });
    });
}
function homeDir() {
    return process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
}
function credentialsFileName() {
    return process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(homeDir(), '.aws', 'credentials');
}
function configFileName() {
    return process.env.AWS_CONFIG_FILE || path.join(homeDir(), '.aws', 'config');
}
/**
 * Force the JS SDK to honor the ~/.aws/config file (and various settings therein)
 *
 * For example, there is just *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set,
 * or read credentials from that file.
 *
 * The SDK crashes if the variable is set but the file does not exist, so conditionally set it.
 */
async function forceSdkToReadConfigIfPresent() {
    if (await fs.pathExists(configFileName())) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        _env_1.debug(e);
        return undefined;
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn, cb) {
    _env_1.debug('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        _env_1.debug('Successfully got MFA token from user');
        cb(undefined, token);
    }
    catch (err) {
        _env_1.debug('Failed to get MFA token', err);
        cb(err);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsaUNBQStCO0FBQy9CLHVEQUFvRTtBQUNwRSxpREFBK0M7QUFFL0M7Ozs7Ozs7R0FPRztBQUNILE1BQWEsZ0JBQWdCO0lBQzNCOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxVQUFrQyxFQUFFO1FBQ3RFLDBFQUEwRTtRQUMxRSx3QkFBd0I7UUFDeEIsTUFBTSw2QkFBNkIsRUFBRSxDQUFDO1FBRXRDLCtFQUErRTtRQUMvRSw2RUFBNkU7UUFDN0Usa0ZBQWtGO1FBQ2xGLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUNuQixPQUFPLElBQUksR0FBRyxDQUFDLHVCQUF1QixDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDMUc7UUFFRCxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixJQUFJLFNBQVMsQ0FBQztRQUVoRyxNQUFNLE9BQU8sR0FBRztZQUNkLEdBQUcsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQztZQUMzQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUM7WUFDOUMsR0FBRywwQkFBMEIsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQztTQUNwRSxDQUFDO1FBRUYsSUFBSSxPQUFPLENBQUMsY0FBYyxJQUFJLGlCQUFpQixFQUFFLEVBQUU7WUFDakQsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO1NBQzlDO2FBQU0sSUFBSSx5QkFBeUIsRUFBRSxFQUFFO1lBQ3RDLG1GQUFtRjtZQUNuRixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLCtCQUErQixFQUFFLENBQUMsQ0FBQztTQUMvRDthQUFNLElBQUksT0FBTyxDQUFDLFdBQVcsSUFBSSxNQUFNLGFBQWEsRUFBRSxFQUFFO1lBQ3ZELHlFQUF5RTtZQUN6RSwyRkFBMkY7WUFDM0Ysa0NBQWtDO1lBQ2xDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsT0FBTyxJQUFJLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVoRCxTQUFTLGtCQUFrQixDQUFDLFdBQW1CO1lBQzdDLE9BQU8sSUFBSSxpREFBK0IsQ0FBQztnQkFDekMsT0FBTyxFQUFFLFdBQVc7Z0JBQ3BCLFFBQVEsRUFBRSxtQkFBbUIsRUFBRTtnQkFDL0IsV0FBVyxFQUFFLE9BQU8sQ0FBQyxXQUFXO2dCQUNoQyxXQUFXO2FBQ1osQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELFNBQVMsMEJBQTBCLENBQUMsVUFBa0IsRUFBRSxjQUFnQztZQUN0RixPQUFPO2dCQUNMLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQztnQkFDcEMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDO29CQUMzQixPQUFPLEVBQUUsVUFBVTtvQkFDbkIsV0FBVyxFQUFFLGNBQWM7aUJBQzVCLENBQUM7Z0JBQ0YsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUM7YUFDMUQsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBeUIsRUFBRTtRQUNwRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLElBQUksU0FBUyxDQUFDO1FBRTNHLDhCQUE4QjtRQUM5QixNQUFNLE9BQU8sR0FBRztZQUNkLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsT0FBTyxFQUFFO1lBQzVDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFO1lBQ3ZELEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRTtTQUNuRSxDQUFDO1FBRUYsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhO1lBQzlELE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQztRQUV0RSxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQztZQUM5QixJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3RDLE1BQU0sVUFBVSxHQUFHLElBQUksNEJBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxPQUFPLEdBQUcsTUFBTSxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDMUQsTUFBTSxHQUFHLE9BQU8sRUFBRSxNQUFNLENBQUM7YUFDMUI7U0FDRjtRQUVELElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxJQUFJLE1BQU0sYUFBYSxFQUFFLENBQUMsRUFBRTtZQUM3RCxZQUFLLENBQUMsb0VBQW9FLENBQUMsQ0FBQztZQUM1RSxNQUFNLFdBQVcsR0FBRztnQkFDbEIsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUM7YUFDcEUsQ0FBQztZQUNGLE1BQU0sZUFBZSxHQUFHLElBQUksR0FBRyxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUU3RCxJQUFJLEtBQUssQ0FBQztZQUNWLElBQUk7Z0JBQ0YsS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQy9DO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsWUFBSyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2hDO1lBRUQsSUFBSTtnQkFDRixNQUFNLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3pELFlBQUssQ0FBQyx5QkFBeUIsTUFBTSxFQUFFLENBQUMsQ0FBQzthQUMxQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLFlBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN4RDtTQUNGO1FBRUQsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sV0FBVyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGVBQWUsT0FBTyxJQUFJLENBQUM7WUFDL0QsTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDLGdDQUFnQztZQUN0RCxZQUFLLENBQUMsdUVBQXVFLFdBQVcsb0JBQW9CLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDeEg7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUF2SUQsNENBdUlDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLGlCQUFpQjtJQUN4QixPQUFRLEdBQUcsQ0FBQyxjQUFjLENBQUMsU0FBaUIsQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO0FBQy9FLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx5QkFBeUI7SUFDaEMsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3RGLENBQUM7QUFFRDs7R0FFRztBQUNILEtBQUssVUFBVSxhQUFhO0lBQzFCLElBQUksa0JBQWtCLEtBQUssU0FBUyxFQUFFO1FBQ3BDLFlBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1FBQ2xELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1lBQ2hDLHFGQUFxRjtZQUNyRixJQUFJO2dCQUNGLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsZ0RBQWdELEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztnQkFDakksb0JBQW9CO2dCQUNwQixRQUFRO2dCQUNSLHVDQUF1QztnQkFDdkMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3REO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsNEdBQTRHO2dCQUM1RyxZQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQyxPQUFPLDZCQUE2QixDQUFDLENBQUM7Z0JBQzNHLFFBQVEsR0FBRyxLQUFLLENBQUM7YUFDbEI7U0FDRjthQUFNO1lBQ0wsa0ZBQWtGO1lBQ2xGLE1BQU0sS0FBSyxHQUE0QjtnQkFDckMsbUVBQW1FO2dCQUNuRSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sQ0FBQztnQkFFakMsb0VBQW9FO2dCQUNwRSw2R0FBNkc7Z0JBQzdHLDREQUE0RDtnQkFDNUQsQ0FBQyx3Q0FBd0MsRUFBRSxNQUFNLENBQUM7YUFDbkQsQ0FBQztZQUNGLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLEVBQUU7Z0JBQzlCLElBQUksWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDMUMsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDaEIsTUFBTTtpQkFDUDthQUNGO1NBQ0Y7UUFDRCxZQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLENBQUMscUNBQXFDLENBQUMsQ0FBQztRQUN4RixrQkFBa0IsR0FBRyxRQUFRLENBQUM7S0FDL0I7SUFDRCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFHRCxJQUFJLGtCQUFrQixHQUF3QixTQUFTLENBQUM7QUFFeEQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsY0FBYyxDQUFDLGVBQW9DO0lBQ2hFLFlBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO0lBQ2pELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDckMsZUFBZSxDQUFDLE9BQU8sQ0FDckIsbUJBQW1CLEVBQ25CO1lBQ0UsTUFBTSxFQUFFLEtBQUs7WUFDYixPQUFPLEVBQUUsRUFBRSxzQ0FBc0MsRUFBRSxJQUFJLEVBQUU7U0FDMUQsRUFDRCxDQUFDLEdBQWlCLEVBQUUsS0FBeUIsRUFBRSxFQUFFO1lBQy9DLElBQUksR0FBRyxFQUFFO2dCQUNQLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNiO2lCQUFNLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ2pCLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUM7YUFDbkQ7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ2hCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7R0FFRztBQUNILEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxlQUFvQyxFQUFFLEtBQXlCO0lBQzlGLFlBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0lBQ2xELElBQUksT0FBTyxHQUF1RixFQUFFLENBQUM7SUFDckcsSUFBSSxLQUFLLEVBQUU7UUFDVCxPQUFPLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRSwwQkFBMEIsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDO0tBQzlEO0lBQ0QsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNyQyxlQUFlLENBQUMsT0FBTyxDQUNyQiw0Q0FBNEMsRUFDNUMsT0FBTyxFQUNQLENBQUMsR0FBaUIsRUFBRSx3QkFBNEMsRUFBRSxFQUFFO1lBQ2xFLElBQUksR0FBRyxFQUFFO2dCQUNQLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNiO2lCQUFNLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtnQkFDcEMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUMsQ0FBQzthQUN6RTtpQkFBTTtnQkFDTCxJQUFJO29CQUNGLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ3REO2dCQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNWLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDWDthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLE9BQU87SUFDZCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVztXQUM3QyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2pILENBQUM7QUFFRCxTQUFTLG1CQUFtQjtJQUMxQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDaEcsQ0FBQztBQUVELFNBQVMsY0FBYztJQUNyQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQy9FLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsS0FBSyxVQUFVLDZCQUE2QjtJQUMxQyxJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxDQUFDO0tBQ3ZDO0FBQ0gsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEVBQVUsRUFBRSxDQUFxQjtJQUNyRCxPQUFPLENBQUMsS0FBSyxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDaEQsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGNBQWMsQ0FBQyxRQUFnQjtJQUN0QyxJQUFJO1FBQ0YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFNBQVMsQ0FBQztTQUFFO1FBQ3ZELE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN6RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsWUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1QsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDO0FBY0Q7Ozs7R0FJRztBQUNILEtBQUssVUFBVSxXQUFXLENBQUMsU0FBaUIsRUFBRSxFQUF5QztJQUNyRixZQUFLLENBQUMsa0NBQWtDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDckQsSUFBSTtRQUNGLE1BQU0sS0FBSyxHQUFXLE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsU0FBUyxJQUFJLEVBQUU7WUFDMUUsSUFBSSxFQUFFLElBQUk7WUFDVixPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUMsQ0FBQztRQUNILFlBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO1FBQzlDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDdEI7SUFBQyxPQUFPLEdBQUcsRUFBRTtRQUNaLFlBQUssQ0FBQyx5QkFBeUIsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN0QyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDVDtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjaGlsZF9wcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vX2Vudic7XG5pbXBvcnQgeyBQYXRjaGVkU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzIH0gZnJvbSAnLi9hd3Mtc2RrLWluaWZpbGUnO1xuaW1wb3J0IHsgU2hhcmVkSW5pRmlsZSB9IGZyb20gJy4vc2RrX2luaV9maWxlJztcblxuLyoqXG4gKiBCZWhhdmlvcnMgdG8gbWF0Y2ggQVdTIENMSVxuICpcbiAqIFNlZSB0aGVzZSBsaW5rczpcbiAqXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC90b3BpYy9jb25maWctdmFycy5odG1sXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC91c2VyZ3VpZGUvY2xpLWNvbmZpZ3VyZS1lbnZ2YXJzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF3c0NsaUNvbXBhdGlibGUge1xuICAvKipcbiAgICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAgICpcbiAgICogVGhpcyBpcyBzaW1pbGFyIHRvIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWwgcHJvdmlkZXIgY2hhaW4gY3JlYXRlZCBieSB0aGUgU0RLXG4gICAqIGV4Y2VwdDpcbiAgICpcbiAgICogMS4gQWNjZXB0cyBwcm9maWxlIGFyZ3VtZW50IGluIHRoZSBjb25zdHJ1Y3RvciAodGhlIFNESyBtdXN0IGhhdmUgaXQgcHJlcG9wdWxhdGVkXG4gICAqICAgIGluIHRoZSBlbnZpcm9ubWVudCkuXG4gICAqIDIuIENvbmRpdGlvbmFsbHkgY2hlY2tzIEVDMiBjcmVkZW50aWFscywgYmVjYXVzZSBjaGVja2luZyBmb3IgRUMyXG4gICAqICAgIGNyZWRlbnRpYWxzIG9uIGEgbm9uLUVDMiBtYWNoaW5lIG1heSBsZWFkIHRvIGxvbmcgZGVsYXlzIChpbiB0aGUgYmVzdCBjYXNlKVxuICAgKiAgICBvciBhbiBleGNlcHRpb24gKGluIHRoZSB3b3JzdCBjYXNlKS5cbiAgICogMy4gUmVzcGVjdHMgJEFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRS5cbiAgICogNC4gUmVzcGVjdHMgJEFXU19ERUZBVUxUX1BST0ZJTEUgaW4gYWRkaXRpb24gdG8gJEFXU19QUk9GSUxFLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVkZW50aWFsQ2hhaW4ob3B0aW9uczogQ3JlZGVudGlhbENoYWluT3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gRm9yY2UgcmVhZGluZyB0aGUgYGNvbmZpZ2AgZmlsZSBpZiBpdCBleGlzdHMgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICBhd2FpdCBmb3JjZVNka1RvUmVhZENvbmZpZ0lmUHJlc2VudCgpO1xuXG4gICAgLy8gVG8gbWF0Y2ggQVdTIENMSSBiZWhhdmlvciwgaWYgYSBwcm9maWxlIGlzIGV4cGxpY2l0bHkgZ2l2ZW4gdXNpbmcgLS1wcm9maWxlLFxuICAgIC8vIHdlIHVzZSB0aGF0IHRvIHRoZSBleGNsdXNpb24gb2YgZXZlcnl0aGluZyBlbHNlIChub3RlOiB0aGlzIGRvZXMgbm90IGFwcGx5XG4gICAgLy8gdG8gQVdTX1BST0ZJTEUsIGVudmlyb25tZW50IGNyZWRlbnRpYWxzIHN0aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIEFXU19QUk9GSUxFKVxuICAgIGlmIChvcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIHJldHVybiBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKGluaUZpbGVDcmVkZW50aWFsRmFjdG9yaWVzKG9wdGlvbnMucHJvZmlsZSwgb3B0aW9ucy5odHRwT3B0aW9ucykpO1xuICAgIH1cblxuICAgIGNvbnN0IGltcGxpY2l0UHJvZmlsZSA9IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgY29uc3Qgc291cmNlcyA9IFtcbiAgICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyksXG4gICAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpLFxuICAgICAgLi4uaW5pRmlsZUNyZWRlbnRpYWxGYWN0b3JpZXMoaW1wbGljaXRQcm9maWxlLCBvcHRpb25zLmh0dHBPcHRpb25zKSxcbiAgICBdO1xuXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyQ3JlZHMgPz8gaGFzRWNzQ3JlZGVudGlhbHMoKSkge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKSk7XG4gICAgfSBlbHNlIGlmIChoYXNXZWJJZGVudGl0eUNyZWRlbnRpYWxzKCkpIHtcbiAgICAgIC8vIGVsc2UgaWY6IHdlIGhhdmUgZm91bmQgV2ViSWRlbnRpdHlDcmVkZW50aWFscyBhcyBwcm92aWRlZCBieSBFS1MgU2VydmljZUFjY291bnRzXG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKCkpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lYzJpbnN0YW5jZSA/PyBhd2FpdCBpc0VjMkluc3RhbmNlKCkpIHtcbiAgICAgIC8vIGVsc2UgaWY6IGRvbid0IGdldCBFQzIgY3JlZHMgaWYgd2Ugc2hvdWxkIGhhdmUgZ290dGVuIEVDUyBvciBFS1MgY3JlZHNcbiAgICAgIC8vIEVDUyBhbmQgRUtTIGluc3RhbmNlcyBhbHNvIHJ1biBvbiBFQzIgYm94ZXMgYnV0IHRoZSBjcmVkcyByZXByZXNlbnQgc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICAgIC8vIFNhbWUgYmVoYXZpb3IgYXMgdXBzdHJlYW0gY29kZS5cbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oc291cmNlcyk7XG5cbiAgICBmdW5jdGlvbiBwcm9maWxlQ3JlZGVudGlhbHMocHJvZmlsZU5hbWU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIG5ldyBQYXRjaGVkU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHtcbiAgICAgICAgcHJvZmlsZTogcHJvZmlsZU5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBjcmVkZW50aWFsc0ZpbGVOYW1lKCksXG4gICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICB0b2tlbkNvZGVGbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaUZpbGVDcmVkZW50aWFsRmFjdG9yaWVzKHRoZVByb2ZpbGU6IHN0cmluZywgdGhlSHR0cE9wdGlvbnM/OiBBV1MuSFRUUE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICgpID0+IHByb2ZpbGVDcmVkZW50aWFscyh0aGVQcm9maWxlKSxcbiAgICAgICAgKCkgPT4gbmV3IEFXUy5Tc29DcmVkZW50aWFscyh7XG4gICAgICAgICAgcHJvZmlsZTogdGhlUHJvZmlsZSxcbiAgICAgICAgICBodHRwT3B0aW9uczogdGhlSHR0cE9wdGlvbnMsXG4gICAgICAgIH0pLFxuICAgICAgICAoKSA9PiBuZXcgQVdTLlByb2Nlc3NDcmVkZW50aWFscyh7IHByb2ZpbGU6IHRoZVByb2ZpbGUgfSksXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgcmVnaW9uIGluIGEgQ0xJLWNvbXBhdGlibGUgd2F5XG4gICAqXG4gICAqIE1vc3RseSBjb3BpZWQgZnJvbSBub2RlX2xvYWRlci5qcywgYnV0IHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlcyB0byBtYWtlIGl0XG4gICAqIEFXUyBDTEkgY29tcGF0aWJsZTpcbiAgICpcbiAgICogMS4gVGFrZXMgYSBwcm9maWxlIG5hbWUgYXMgYW4gYXJndW1lbnQgKGluc3RlYWQgb2YgZm9yY2luZyBpdCB0byBiZSB0YWtlbiBmcm9tICRBV1NfUFJPRklMRSkuXG4gICAqICAgIFRoaXMgcmVxdWlyZXMgaGF2aW5nIG1hZGUgYSBjb3B5IG9mIHRoZSBTREsncyBgU2hhcmVkSW5pRmlsZWAgKHRoZSBvcmlnaW5hbFxuICAgKiAgICBkb2VzIG5vdCB0YWtlIGFuIGFyZ3VtZW50KS5cbiAgICogMi4gJEFXU19ERUZBVUxUX1BST0ZJTEUgYW5kICRBV1NfREVGQVVMVF9SRUdJT04gYXJlIGFsc28gcmVzcGVjdGVkLlxuICAgKlxuICAgKiBMYW1iZGEgYW5kIENvZGVCdWlsZCBzZXQgdGhlICRBV1NfUkVHSU9OIHZhcmlhYmxlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyByZWdpb24ob3B0aW9uczogUmVnaW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBwcm9maWxlID0gb3B0aW9ucy5wcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgLy8gRGVmYXVsdHMgaW5zaWRlIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgdG9DaGVjayA9IFtcbiAgICAgIHsgZmlsZW5hbWU6IGNyZWRlbnRpYWxzRmlsZU5hbWUoKSwgcHJvZmlsZSB9LFxuICAgICAgeyBpc0NvbmZpZzogdHJ1ZSwgZmlsZW5hbWU6IGNvbmZpZ0ZpbGVOYW1lKCksIHByb2ZpbGUgfSxcbiAgICAgIHsgaXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBjb25maWdGaWxlTmFtZSgpLCBwcm9maWxlOiAnZGVmYXVsdCcgfSxcbiAgICBdO1xuXG4gICAgbGV0IHJlZ2lvbiA9IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9ERUZBVUxUX1JFR0lPTjtcblxuICAgIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IHRvQ2hlY2suc2hpZnQoKSE7XG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhvcHRzLmZpbGVuYW1lKSkge1xuICAgICAgICBjb25zdCBjb25maWdGaWxlID0gbmV3IFNoYXJlZEluaUZpbGUob3B0cyk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBhd2FpdCBjb25maWdGaWxlLmdldFByb2ZpbGUob3B0cy5wcm9maWxlKTtcbiAgICAgICAgcmVnaW9uID0gc2VjdGlvbj8ucmVnaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVnaW9uICYmIChvcHRpb25zLmVjMmluc3RhbmNlID8/IGF3YWl0IGlzRWMySW5zdGFuY2UoKSkpIHtcbiAgICAgIGRlYnVnKCdMb29raW5nIHVwIEFXUyByZWdpb24gaW4gdGhlIEVDMiBJbnN0YW5jZSBNZXRhZGF0YSBTZXJ2aWNlIChJTURTKS4nKTtcbiAgICAgIGNvbnN0IGltZHNPcHRpb25zID0ge1xuICAgICAgICBodHRwT3B0aW9uczogeyB0aW1lb3V0OiAxMDAwLCBjb25uZWN0VGltZW91dDogMTAwMCB9LCBtYXhSZXRyaWVzOiAyLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhU2VydmljZSA9IG5ldyBBV1MuTWV0YWRhdGFTZXJ2aWNlKGltZHNPcHRpb25zKTtcblxuICAgICAgbGV0IHRva2VuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW4gPSBhd2FpdCBnZXRJbWRzVjJUb2tlbihtZXRhZGF0YVNlcnZpY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyhgTm8gSU1EU3YyIHRva2VuOiAke2V9YCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZ2lvbiA9IGF3YWl0IGdldFJlZ2lvbkZyb21JbWRzKG1ldGFkYXRhU2VydmljZSwgdG9rZW4pO1xuICAgICAgICBkZWJ1ZyhgQVdTIHJlZ2lvbiBmcm9tIElNRFM6ICR7cmVnaW9ufWApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyhgVW5hYmxlIHRvIHJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBJTURTOiAke2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZWdpb24pIHtcbiAgICAgIGNvbnN0IHVzZWRQcm9maWxlID0gIXByb2ZpbGUgPyAnJyA6IGAgKHByb2ZpbGU6IFwiJHtwcm9maWxlfVwiKWA7XG4gICAgICByZWdpb24gPSAndXMtZWFzdC0xJzsgLy8gVGhpcyBpcyB3aGF0IHRoZSBBV1MgQ0xJIGRvZXNcbiAgICAgIGRlYnVnKGBVbmFibGUgdG8gZGV0ZXJtaW5lIEFXUyByZWdpb24gZnJvbSBlbnZpcm9ubWVudCBvciBBV1MgY29uZmlndXJhdGlvbiR7dXNlZFByb2ZpbGV9LCBkZWZhdWx0aW5nIHRvICcke3JlZ2lvbn0nYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGl0IGxvb2tzIGxpa2Ugd2UnbGwgaGF2ZSBFQ1MgY3JlZGVudGlhbHMgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGhhc0Vjc0NyZWRlbnRpYWxzKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKEFXUy5FQ1NDcmVkZW50aWFscy5wcm90b3R5cGUgYXMgYW55KS5pc0NvbmZpZ3VyZWRGb3JFY3NDcmVkZW50aWFscygpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGl0IGxvb2tzIGxpa2Ugd2UnbGwgaGF2ZSBXZWJJZGVudGl0eUNyZWRlbnRpYWxzICh0aGF0J3Mgd2hhdCBFS1MgdXNlcykgYXZhaWxhYmxlXG4gKiBObyBjaGVjayBsaWtlIGhhc0Vjc0NyZWRlbnRpYWxzIGF2YWlsYWJsZSwgc28gaGF2ZSB0byBpbXBsZW1lbnQgb3VyIG93bi5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2Jsb2IvM2NjZmQ5NGRhMDcyMzRhZTg3MDM3ZjU1YzEzODM5MmYzOGI2ODgxZC9saWIvY3JlZGVudGlhbHMvdG9rZW5fZmlsZV93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMuanMjTDU5XG4gKi9cbmZ1bmN0aW9uIGhhc1dlYklkZW50aXR5Q3JlZGVudGlhbHMoKTogYm9vbGVhbiB7XG4gIHJldHVybiBCb29sZWFuKHByb2Nlc3MuZW52LkFXU19ST0xFX0FSTiAmJiBwcm9jZXNzLmVudi5BV1NfV0VCX0lERU5USVRZX1RPS0VOX0ZJTEUpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBpc0VjMkluc3RhbmNlKCkge1xuICBpZiAoaXNFYzJJbnN0YW5jZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhcIkRldGVybWluaW5nIGlmIHdlJ3JlIG9uIGFuIEVDMiBpbnN0YW5jZS5cIik7XG4gICAgbGV0IGluc3RhbmNlID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1dpbmRvd3NHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHV0aWwucHJvbWlzaWZ5KGNoaWxkX3Byb2Nlc3MuZXhlYykoJ3dtaWMgcGF0aCB3aW4zMl9jb21wdXRlcnN5c3RlbXByb2R1Y3QgZ2V0IHV1aWQnLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgICAgICAvLyBvdXRwdXQgbG9va3MgbGlrZVxuICAgICAgICAvLyAgVVVJRFxuICAgICAgICAvLyAgRUMyQUUxNDUtRDFEQy0xM0IyLTk0RUQtMDEyMzRBQkNERUZcbiAgICAgICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICBpbnN0YW5jZSA9IGxpbmVzLnNvbWUoeCA9PiBtYXRjaGVzUmVnZXgoL15lYzIvaSwgeCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBNb2Rlcm4gbWFjaGluZXMgbWF5IG5vdCBoYXZlIHdtaWMuZXhlIGluc3RhbGxlZC4gTm8gcmVhc29uIHRvIGZhaWwsIGp1c3QgYXNzdW1lIGl0J3Mgbm90IGFuIEVDMiBpbnN0YW5jZS5cbiAgICAgICAgZGVidWcoYENoZWNraW5nIHVzaW5nIFdNSUMgZmFpbGVkLCBhc3N1bWluZyBOT1QgYW4gRUMyIGluc3RhbmNlOiAke2UubWVzc2FnZX0gKHBhc3MgLS1lYzJjcmVkcyB0byBmb3JjZSlgKTtcbiAgICAgICAgaW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvVXNlckd1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgICAgY29uc3QgZmlsZXM6IEFycmF5PFtzdHJpbmcsIFJlZ0V4cF0+ID0gW1xuICAgICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIFhlbiBoeXBlcnZpc29yIGJhc2VkIGluc3RhbmNlcyAocHJlLTV0aCBnZW4pXG4gICAgICAgIFsnL3N5cy9oeXBlcnZpc29yL3V1aWQnLCAvXmVjMi9pXSxcblxuICAgICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIG5ldyBIeXBlcnZpc29yICg1dGgtZ2VuIGluc3RhbmNlcyBhbmQgaGlnaGVyKVxuICAgICAgICAvLyBDYW4ndCB1c2UgdGhlIGFkdmVydGlzZWQgZmlsZSAnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfdXVpZCcgYmVjYXVzZSBpdCByZXF1aXJlcyByb290IHRvIHJlYWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHN5c192ZW5kb3IgY29udGFpbnMgc29tZXRoaW5nIGxpa2UgJ0FtYXpvbiBFQzInLlxuICAgICAgICBbJy9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9zeXNfdmVuZG9yJywgL2VjMi9pXSxcbiAgICAgIF07XG4gICAgICBmb3IgKGNvbnN0IFtmaWxlLCByZV0gb2YgZmlsZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoZXNSZWdleChyZSwgcmVhZElmUG9zc2libGUoZmlsZSkpKSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnKGluc3RhbmNlID8gJ0xvb2tzIGxpa2UgYW4gRUMyIGluc3RhbmNlLicgOiAnRG9lcyBub3QgbG9vayBsaWtlIGFuIEVDMiBpbnN0YW5jZS4nKTtcbiAgICBpc0VjMkluc3RhbmNlQ2FjaGUgPSBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gaXNFYzJJbnN0YW5jZUNhY2hlO1xufVxuXG5cbmxldCBpc0VjMkluc3RhbmNlQ2FjaGU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGEgSW5zdGFuY2UgTWV0YWRhdGEgU2VydmljZSBWMiB0b2tlblxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWRzVjJUb2tlbihtZXRhZGF0YVNlcnZpY2U6IEFXUy5NZXRhZGF0YVNlcnZpY2UpOiBQcm9taXNlPHN0cmluZz4ge1xuICBkZWJ1ZygnQXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBJTURTdjIgdG9rZW4uJyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbWV0YWRhdGFTZXJ2aWNlLnJlcXVlc3QoXG4gICAgICAnL2xhdGVzdC9hcGkvdG9rZW4nLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICd4LWF3cy1lYzItbWV0YWRhdGEtdG9rZW4tdHRsLXNlY29uZHMnOiAnNjAnIH0sXG4gICAgICB9LFxuICAgICAgKGVycjogQVdTLkFXU0Vycm9yLCB0b2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICghdG9rZW4pIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJTURTIGRpZCBub3QgcmV0dXJuIGEgdG9rZW4uJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IHRoZSByZWdpb24gZnJvbSB0aGUgSW5zdGFuY2UgTWV0YWRhdGEgU2VydmljZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZWdpb25Gcm9tSW1kcyhtZXRhZGF0YVNlcnZpY2U6IEFXUy5NZXRhZGF0YVNlcnZpY2UsIHRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHN0cmluZz4ge1xuICBkZWJ1ZygnUmV0cmlldmluZyB0aGUgQVdTIHJlZ2lvbiBmcm9tIHRoZSBJTURTLicpO1xuICBsZXQgb3B0aW9uczogeyBtZXRob2Q/OiBzdHJpbmcgfCB1bmRlZmluZWQ7IGhlYWRlcnM/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfSB8IHVuZGVmaW5lZDsgfSA9IHt9O1xuICBpZiAodG9rZW4pIHtcbiAgICBvcHRpb25zID0geyBoZWFkZXJzOiB7ICd4LWF3cy1lYzItbWV0YWRhdGEtdG9rZW4nOiB0b2tlbiB9IH07XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtZXRhZGF0YVNlcnZpY2UucmVxdWVzdChcbiAgICAgICcvbGF0ZXN0L2R5bmFtaWMvaW5zdGFuY2UtaWRlbnRpdHkvZG9jdW1lbnQnLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIChlcnI6IEFXUy5BV1NFcnJvciwgaW5zdGFuY2VJZGVudGl0eURvY3VtZW50OiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZUlkZW50aXR5RG9jdW1lbnQpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJTURTIGRpZCBub3QgcmV0dXJuIGFuIEluc3RhbmNlIElkZW50aXR5IERvY3VtZW50LicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKGluc3RhbmNlSWRlbnRpdHlEb2N1bWVudCkucmVnaW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhvbWVEaXIoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFXG4gICAgfHwgKHByb2Nlc3MuZW52LkhPTUVQQVRIID8gKChwcm9jZXNzLmVudi5IT01FRFJJVkUgfHwgJ0M6LycpICsgcHJvY2Vzcy5lbnYuSE9NRVBBVEgpIDogbnVsbCkgfHwgb3MuaG9tZWRpcigpO1xufVxuXG5mdW5jdGlvbiBjcmVkZW50aWFsc0ZpbGVOYW1lKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFIHx8IHBhdGguam9pbihob21lRGlyKCksICcuYXdzJywgJ2NyZWRlbnRpYWxzJyk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVOYW1lKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX0NPTkZJR19GSUxFIHx8IHBhdGguam9pbihob21lRGlyKCksICcuYXdzJywgJ2NvbmZpZycpO1xufVxuXG4vKipcbiAqIEZvcmNlIHRoZSBKUyBTREsgdG8gaG9ub3IgdGhlIH4vLmF3cy9jb25maWcgZmlsZSAoYW5kIHZhcmlvdXMgc2V0dGluZ3MgdGhlcmVpbilcbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlcmUgaXMganVzdCAqTk8qIHdheSB0byBkbyBBc3N1bWVSb2xlIGNyZWRlbnRpYWxzIGFzIGxvbmcgYXMgQVdTX1NES19MT0FEX0NPTkZJRyBpcyBub3Qgc2V0LFxuICogb3IgcmVhZCBjcmVkZW50aWFscyBmcm9tIHRoYXQgZmlsZS5cbiAqXG4gKiBUaGUgU0RLIGNyYXNoZXMgaWYgdGhlIHZhcmlhYmxlIGlzIHNldCBidXQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIHNvIGNvbmRpdGlvbmFsbHkgc2V0IGl0LlxuICovXG5hc3luYyBmdW5jdGlvbiBmb3JjZVNka1RvUmVhZENvbmZpZ0lmUHJlc2VudCgpIHtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoY29uZmlnRmlsZU5hbWUoKSkpIHtcbiAgICBwcm9jZXNzLmVudi5BV1NfU0RLX0xPQURfQ09ORklHID0gJzEnO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXNSZWdleChyZTogUmVnRXhwLCBzOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHMgIT09IHVuZGVmaW5lZCAmJiByZS5leGVjKHMpICE9PSBudWxsO1xufVxuXG4vKipcbiAqIFJlYWQgYSBmaWxlIGlmIGl0IGV4aXN0cywgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICpcbiAqIE5vdCBhc3luYyBiZWNhdXNlIGl0IGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHJlYWRJZlBvc3NpYmxlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGlmICghZnMucGF0aEV4aXN0c1N5bmMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoZSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWRlbnRpYWxDaGFpbk9wdGlvbnMge1xuICByZWFkb25seSBwcm9maWxlPzogc3RyaW5nO1xuICByZWFkb25seSBlYzJpbnN0YW5jZT86IGJvb2xlYW47XG4gIHJlYWRvbmx5IGNvbnRhaW5lckNyZWRzPzogYm9vbGVhbjtcbiAgcmVhZG9ubHkgaHR0cE9wdGlvbnM/OiBBV1MuSFRUUE9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaW9uT3B0aW9ucyB7XG4gIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVjMmluc3RhbmNlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBc2sgdXNlciBmb3IgTUZBIHRva2VuIGZvciBnaXZlbiBzZXJpYWxcbiAqXG4gKiBSZXN1bHQgaXMgc2VuZCB0byBjYWxsYmFjayBmdW5jdGlvbiBmb3IgU0RLIHRvIGF1dGhvcml6ZSB0aGUgcmVxdWVzdFxuICovXG5hc3luYyBmdW5jdGlvbiB0b2tlbkNvZGVGbihzZXJpYWxBcm46IHN0cmluZywgY2I6IChlcnI/OiBFcnJvciwgdG9rZW4/OiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgZGVidWcoJ1JlcXVpcmUgTUZBIHRva2VuIGZvciBzZXJpYWwgQVJOJywgc2VyaWFsQXJuKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID0gYXdhaXQgcHJvbXB0bHkucHJvbXB0KGBNRkEgdG9rZW4gZm9yICR7c2VyaWFsQXJufTogYCwge1xuICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgIH0pO1xuICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgZ290IE1GQSB0b2tlbiBmcm9tIHVzZXInKTtcbiAgICBjYih1bmRlZmluZWQsIHRva2VuKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcoJ0ZhaWxlZCB0byBnZXQgTUZBIHRva2VuJywgZXJyKTtcbiAgICBjYihlcnIpO1xuICB9XG59Il19