"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const chalk = require("chalk");
const bootstrap_props_1 = require("./bootstrap/bootstrap-props");
const cloudformation_1 = require("./util/cloudformation");
const logging_1 = require("../logging");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * The bootstrap template version that introduced ssm:GetParameter
 */
const BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 */
class ToolkitInfo {
    constructor(sdk) {
        this.sdk = sdk;
        this.ssmCache = new Map();
    }
    static determineName(overrideName) {
        return overrideName ?? exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    static async lookup(environment, sdk, stackName) {
        const cfn = sdk.cloudFormation();
        const stack = await cloudformation_1.stabilizeStack(cfn, stackName ?? exports.DEFAULT_TOOLKIT_STACK_NAME);
        if (!stack) {
            logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        if (stack.stackStatus.isCreationFailure) {
            // Treat a "failed to create" bootstrap stack as an absent one.
            logging_1.debug('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        return new ExistingToolkitInfo(stack, sdk);
    }
    static fromStack(stack, sdk) {
        return new ExistingToolkitInfo(stack, sdk);
    }
    static bootstraplessDeploymentsOnly(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI.');
    }
    static bootstrapStackNotFoundInfo(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'This deployment requires a bootstrap stack with a known name; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)');
    }
    /**
     * Read a version from an SSM parameter, cached
     */
    static async versionFromSsmParameter(sdk, parameterName, ssmCache) {
        const existing = ssmCache?.get(parameterName);
        if (existing !== undefined) {
            return existing;
        }
        const ssm = sdk.ssm();
        try {
            const result = await ssm.getParameter({ Name: parameterName }).promise();
            const asNumber = parseInt(`${result.Parameter?.Value}`, 10);
            if (isNaN(asNumber)) {
                throw new Error(`SSM parameter ${parameterName} not a number: ${result.Parameter?.Value}`);
            }
            ssmCache?.set(parameterName, asNumber);
            return asNumber;
        }
        catch (e) {
            if (e.code === 'ParameterNotFound') {
                throw new Error(`SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run \'cdk bootstrap\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
            }
            throw e;
        }
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack, sdk) {
        super(sdk);
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_props_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_props_1.BUCKET_NAME_OUTPUT);
    }
    get version() {
        return parseInt(this.bootstrapStack.outputs[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT] ?? '0', 10);
    }
    get variant() {
        return this.bootstrapStack.parameters[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER] ?? bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
    }
    get parameters() {
        return this.bootstrapStack.parameters ?? {};
    }
    get terminationProtection() {
        return this.bootstrapStack.terminationProtection ?? false;
    }
    /**
     * Validate that the bootstrap stack version matches or exceeds the expected version
     *
     * Use the SSM parameter name to read the version number if given, otherwise use the version
     * discovered on the bootstrap stack.
     *
     * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
     * lookup again and again for every artifact.
     */
    async validateVersion(expectedVersion, ssmParameterName) {
        let version = this.version; // Default to the current version, but will be overwritten by a lookup if required.
        if (ssmParameterName !== undefined) {
            try {
                version = await ToolkitInfo.versionFromSsmParameter(this.sdk, ssmParameterName, this.ssmCache);
            }
            catch (e) {
                if (e.code !== 'AccessDeniedException') {
                    throw e;
                }
                // This is a fallback! The bootstrap template that goes along with this change introduces
                // a new 'ssm:GetParameter' permission, but when run using the previous bootstrap template we
                // won't have the permissions yet to read the version, so we won't be able to show the
                // message telling the user they need to update! When we see an AccessDeniedException, fall
                // back to the version we read from Stack Outputs; but ONLY if the version we discovered via
                // outputs is legitimately an old version. If it's newer than that, something else must be broken,
                // so let it fail as it would if we didn't have this fallback.
                if (this.version >= BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
                    throw e;
                }
                logging_1.warning(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
                // Fall through on purpose
            }
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     */
    async prepareEcrRepository(repositoryName) {
        if (!this.sdk) {
            throw new Error('ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository');
        }
        const ecr = this.sdk.ecr();
        // check if repo already exists
        try {
            logging_1.debug(`${repositoryName}: checking if ECR repository already exists`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            const existingRepositoryUri = describeResponse.repositories[0]?.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        logging_1.debug(`${repositoryName}: creating ECR repository`);
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({ repositoryName, tags: [assetTag] }).promise();
        const repositoryUri = response.repository?.repositoryUri;
        if (!repositoryUri) {
            throw new Error(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        logging_1.debug(`${repositoryName}: enable image scanning`);
        await ecr.putImageScanningConfiguration({ repositoryName, imageScanningConfiguration: { scanOnPush: true } }).promise();
        return { repositoryUri };
    }
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new Error(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(sdk, errorMessage) {
        super(sdk);
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new Error(this.errorMessage);
    }
    get bucketUrl() {
        throw new Error(this.errorMessage);
    }
    get bucketName() {
        throw new Error(this.errorMessage);
    }
    get version() {
        throw new Error(this.errorMessage);
    }
    get variant() {
        throw new Error(this.errorMessage);
    }
    async validateVersion(expectedVersion, ssmParameterName) {
        if (ssmParameterName === undefined) {
            throw new Error(this.errorMessage);
        }
        let version;
        try {
            version = await ToolkitInfo.versionFromSsmParameter(this.sdk, ssmParameterName, this.ssmCache);
        }
        catch (e) {
            if (e.code !== 'AccessDeniedException') {
                throw e;
            }
            // This is a fallback! The bootstrap template that goes along with this change introduces
            // a new 'ssm:GetParameter' permission, but when run using a previous bootstrap template we
            // won't have the permissions yet to read the version, so we won't be able to show the
            // message telling the user they need to update! When we see an AccessDeniedException, fall
            // back to the version we read from Stack Outputs.
            logging_1.warning(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found an older version. Please run 'cdk bootstrap'.`);
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    prepareEcrRepository() {
        throw new Error(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUUvQixpRUFBOEs7QUFDOUssMERBQTRFO0FBQzVFLHdDQUE0QztBQUUvQixRQUFBLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUV2RDs7R0FFRztBQUNILE1BQU0sbURBQW1ELEdBQUcsQ0FBQyxDQUFDO0FBRTlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBc0IsV0FBVztJQXNFL0IsWUFBK0IsR0FBUztRQUFULFFBQUcsR0FBSCxHQUFHLENBQU07UUFSckIsYUFBUSxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0lBU3hELENBQUM7SUF0RU0sTUFBTSxDQUFDLGFBQWEsQ0FBQyxZQUFxQjtRQUMvQyxPQUFPLFlBQVksSUFBSSxrQ0FBMEIsQ0FBQztJQUNwRCxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBOEIsRUFBRSxHQUFTLEVBQUUsU0FBNkI7UUFDakcsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sS0FBSyxHQUFHLE1BQU0sK0JBQWMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxJQUFJLGtDQUEwQixDQUFDLENBQUM7UUFDakYsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLGVBQUssQ0FBQyxtSUFBbUksRUFDdkksV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsRixPQUFPLFdBQVcsQ0FBQywwQkFBMEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNwRDtRQUNELElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRTtZQUN2QywrREFBK0Q7WUFDL0QsZUFB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O0lBQ0gsQ0FBQztJQUVNLG9CQUFvQjtRQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQk9PVFNUUkFQX1ZFUlNJT05fT1VUUFVULCBCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVULCBCVUNLRVRfTkFNRV9PVVRQVVQsIEJPT1RTVFJBUF9WQVJJQU5UX1BBUkFNRVRFUiwgREVGQVVMVF9CT09UU1RSQVBfVkFSSUFOVCB9IGZyb20gJy4vYm9vdHN0cmFwL2Jvb3RzdHJhcC1wcm9wcyc7XG5pbXBvcnQgeyBzdGFiaWxpemVTdGFjaywgQ2xvdWRGb3JtYXRpb25TdGFjayB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgPSAnQ0RLVG9vbGtpdCc7XG5cbi8qKlxuICogVGhlIGJvb3RzdHJhcCB0ZW1wbGF0ZSB2ZXJzaW9uIHRoYXQgaW50cm9kdWNlZCBzc206R2V0UGFyYW1ldGVyXG4gKi9cbmNvbnN0IEJPT1RTVFJBUF9URU1QTEFURV9WRVJTSU9OX0lOVFJPRFVDSU5HX0dFVFBBUkFNRVRFUiA9IDU7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gb24gdGhlIEJvb3RzdHJhcCBzdGFjayBvZiB0aGUgZW52aXJvbm1lbnQgd2UncmUgZGVwbG95aW5nIHRvLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2VydmVzIHRvOlxuICpcbiAqIC0gSW5zcGVjdCB0aGUgYm9vdHN0cmFwIHN0YWNrLCBhbmQgcmV0dXJuIHZhcmlvdXMgcHJvcGVydGllcyBvZiBpdCBmb3Igc3VjY2Vzc2Z1bFxuICogICBhc3NldCBkZXBsb3ltZW50IChpbiBjYXNlIG9mIGxlZ2FjeS1zeW50aGVzaXplZCBzdGFja3MpLlxuICogLSBWYWxpZGF0ZSB0aGUgdmVyc2lvbiBvZiB0aGUgdGFyZ2V0IGVudmlyb25tZW50LCBhbmQgbm90aGluZyBlbHNlIChpbiBjYXNlIG9mXG4gKiAgIGRlZmF1bHQtc3ludGhlc2l6ZWQgc3RhY2tzKS5cbiAqXG4gKiBBbiBvYmplY3Qgb2YgdGhpcyB0eXBlIG1pZ2h0IHJlcHJlc2VudCBhIGJvb3RzdHJhcCBzdGFjayB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAqIFRoaXMgaXMgbm90IGFuIGlzc3VlIHVubGVzcyBhbnkgbWVtYmVycyBhcmUgdXNlZCB0aGF0IHJlcXVpcmUgdGhlIGJvb3RzdHJhcCBzdGFja1xuICogdG8gaGF2ZSBiZWVuIGZvdW5kLCBpbiB3aGljaCBjYXNlIGFuIGVycm9yIGlzIHRocm93biAoZGVmYXVsdC1zeW50aGVzaXplZCBzdGFja3NcbiAqIHNob3VsZCBuZXZlciBydW4gaW50byB0aGlzIGFzIHRoZXkgZG9uJ3QgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBib290c3RyYXBcbiAqIHN0YWNrLCBhbGwgaW5mb3JtYXRpb24gaXMgYWxyZWFkeSBlbmNvZGVkIGludG8gdGhlIENsb3VkIEFzc2VtYmx5IE1hbmlmZXN0KS5cbiAqXG4gKiBOZXZlcnRoZWxlc3MsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZXhpc3RzIHRvIHNlcnZlIGFzIGEgY2FjaGUgZm9yIFNTTVxuICogcGFyYW1ldGVyIGxvb2t1cHMgKG90aGVyd2lzZSwgdGhlIFwiYm9vdHN0cmFwIHN0YWNrIHZlcnNpb25cIiBwYXJhbWV0ZXIgd291bGRcbiAqIG5lZWQgdG8gYmUgcmVhZCByZXBlYXRlZGx5KS5cbiAqXG4gKiBDYWxsZWQgXCJUb29sa2l0SW5mb1wiIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVG9vbGtpdEluZm8ge1xuICBwdWJsaWMgc3RhdGljIGRldGVybWluZU5hbWUob3ZlcnJpZGVOYW1lPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBJU0RLLCBzdGFja05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8VG9vbGtpdEluZm8+IHtcbiAgICBjb25zdCBjZm4gPSBzZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FKTtcbiAgICBpZiAoIXN0YWNrKSB7XG4gICAgICBkZWJ1ZygnVGhlIGVudmlyb25tZW50ICVzIGRvZXNuXFwndCBoYXZlIHRoZSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIGluc3RhbGxlZC4gVXNlICVzIHRvIHNldHVwIHlvdXIgZW52aXJvbm1lbnQgZm9yIHVzZSB3aXRoIHRoZSB0b29sa2l0LicsXG4gICAgICAgIGVudmlyb25tZW50Lm5hbWUsIHN0YWNrTmFtZSwgY2hhbGsuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApKTtcbiAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzZGspO1xuICAgIH1cbiAgICBpZiAoc3RhY2suc3RhY2tTdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICAgIC8vIFRyZWF0IGEgXCJmYWlsZWQgdG8gY3JlYXRlXCIgYm9vdHN0cmFwIHN0YWNrIGFzIGFuIGFic2VudCBvbmUuXG4gICAgICBkZWJ1ZygnVGhlIGVudmlyb25tZW50ICVzIGhhcyBhIENESyB0b29sa2l0IHN0YWNrICglcykgdGhhdCBmYWlsZWQgdG8gY3JlYXRlLiBVc2UgJXMgdG8gdHJ5IHByb3Zpc2lvbmluZyBpdCBhZ2Fpbi4nLFxuICAgICAgICBlbnZpcm9ubWVudC5uYW1lLCBzdGFja05hbWUsIGNoYWxrLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSk7XG4gICAgICByZXR1cm4gVG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEV4aXN0aW5nVG9vbGtpdEluZm8oc3RhY2ssIHNkayk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21TdGFjayhzdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaywgc2RrOiBJU0RLKTogVG9vbGtpdEluZm8ge1xuICAgIHJldHVybiBuZXcgRXhpc3RpbmdUb29sa2l0SW5mbyhzdGFjaywgc2RrKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwbGVzc0RlcGxveW1lbnRzT25seShzZGs6IElTREspOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzZGssICdUcnlpbmcgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyBhIGJvb3RzdHJhcCBzdGFjazsgeW91IHNob3VsZCBub3Qgc2VlIHRoaXMgZXJyb3IsIHRoaXMgaXMgYSBidWcgaW4gdGhlIENESyBDTEkuJyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHNkazogSVNESyk6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHNkaywgJ1RoaXMgZGVwbG95bWVudCByZXF1aXJlcyBhIGJvb3RzdHJhcCBzdGFjayB3aXRoIGEga25vd24gbmFtZTsgcGFzcyBcXCctLXRvb2xraXQtc3RhY2stbmFtZVxcJyBvciBzd2l0Y2ggdG8gdXNpbmcgdGhlIFxcJ0RlZmF1bHRTdGFja1N5bnRoZXNpemVyXFwnIChzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay9sYXRlc3QvZ3VpZGUvYm9vdHN0cmFwcGluZy5odG1sKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSB2ZXJzaW9uIGZyb20gYW4gU1NNIHBhcmFtZXRlciwgY2FjaGVkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHNkazogSVNESywgcGFyYW1ldGVyTmFtZTogc3RyaW5nLCBzc21DYWNoZT86IE1hcDxzdHJpbmcsIG51bWJlcj4pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gc3NtQ2FjaGU/LmdldChwYXJhbWV0ZXJOYW1lKTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZXhpc3Rpbmc7IH1cblxuICAgIGNvbnN0IHNzbSA9IHNkay5zc20oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzc20uZ2V0UGFyYW1ldGVyKHsgTmFtZTogcGFyYW1ldGVyTmFtZSB9KS5wcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFzTnVtYmVyID0gcGFyc2VJbnQoYCR7cmVzdWx0LlBhcmFtZXRlcj8uVmFsdWV9YCwgMTApO1xuICAgICAgaWYgKGlzTmFOKGFzTnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTTSBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJOYW1lfSBub3QgYSBudW1iZXI6ICR7cmVzdWx0LlBhcmFtZXRlcj8uVmFsdWV9YCk7XG4gICAgICB9XG5cbiAgICAgIHNzbUNhY2hlPy5zZXQocGFyYW1ldGVyTmFtZSwgYXNOdW1iZXIpO1xuICAgICAgcmV0dXJuIGFzTnVtYmVyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdQYXJhbWV0ZXJOb3RGb3VuZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTU00gcGFyYW1ldGVyICR7cGFyYW1ldGVyTmFtZX0gbm90IGZvdW5kLiBIYXMgdGhlIGVudmlyb25tZW50IGJlZW4gYm9vdHN0cmFwcGVkPyBQbGVhc2UgcnVuIFxcJ2NkayBib290c3RyYXBcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZWFkb25seSBzc21DYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBmb3VuZDogYm9vbGVhbjtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJ1Y2tldFVybDogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgYnVja2V0TmFtZTogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdmVyc2lvbjogbnVtYmVyO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdmFyaWFudDogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2s7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IHNkazogSVNESykge1xuICB9XG4gIHB1YmxpYyBhYnN0cmFjdCB2YWxpZGF0ZVZlcnNpb24oZXhwZWN0ZWRWZXJzaW9uOiBudW1iZXIsIHNzbVBhcmFtZXRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD47XG4gIHB1YmxpYyBhYnN0cmFjdCBwcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz47XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGJvb3RzdHJhcCBzdGFjayBpcyBmb3VuZFxuICovXG5jbGFzcyBFeGlzdGluZ1Rvb2xraXRJbmZvIGV4dGVuZHMgVG9vbGtpdEluZm8ge1xuICBwdWJsaWMgcmVhZG9ubHkgZm91bmQgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBib290c3RyYXBTdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaywgc2RrOiBJU0RLKSB7XG4gICAgc3VwZXIoc2RrKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCkge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMucmVxdWlyZU91dHB1dChCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVUKX1gO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVPdXRwdXQoQlVDS0VUX05BTUVfT1VUUFVUKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5ib290c3RyYXBTdGFjay5vdXRwdXRzW0JPT1RTVFJBUF9WRVJTSU9OX09VVFBVVF0gPz8gJzAnLCAxMCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVyc1tCT09UU1RSQVBfVkFSSUFOVF9QQVJBTUVURVJdID8/IERFRkFVTFRfQk9PVFNUUkFQX1ZBUklBTlQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVycyA/PyB7fTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHRoZSBib290c3RyYXAgc3RhY2sgdmVyc2lvbiBtYXRjaGVzIG9yIGV4Y2VlZHMgdGhlIGV4cGVjdGVkIHZlcnNpb25cbiAgICpcbiAgICogVXNlIHRoZSBTU00gcGFyYW1ldGVyIG5hbWUgdG8gcmVhZCB0aGUgdmVyc2lvbiBudW1iZXIgaWYgZ2l2ZW4sIG90aGVyd2lzZSB1c2UgdGhlIHZlcnNpb25cbiAgICogZGlzY292ZXJlZCBvbiB0aGUgYm9vdHN0cmFwIHN0YWNrLlxuICAgKlxuICAgKiBQYXNzIGluIHRoZSBTU00gcGFyYW1ldGVyIG5hbWUgc28gd2UgY2FuIGNhY2hlIHRoZSBsb29rdXBzIGFuIGRvbid0IG5lZWQgdG8gZG8gdGhlIHNhbWVcbiAgICogbG9va3VwIGFnYWluIGFuZCBhZ2FpbiBmb3IgZXZlcnkgYXJ0aWZhY3QuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdmFsaWRhdGVWZXJzaW9uKGV4cGVjdGVkVmVyc2lvbjogbnVtYmVyLCBzc21QYXJhbWV0ZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjsgLy8gRGVmYXVsdCB0byB0aGUgY3VycmVudCB2ZXJzaW9uLCBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBhIGxvb2t1cCBpZiByZXF1aXJlZC5cblxuICAgIGlmIChzc21QYXJhbWV0ZXJOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBhd2FpdCBUb29sa2l0SW5mby52ZXJzaW9uRnJvbVNzbVBhcmFtZXRlcih0aGlzLnNkaywgc3NtUGFyYW1ldGVyTmFtZSwgdGhpcy5zc21DYWNoZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgIT09ICdBY2Nlc3NEZW5pZWRFeGNlcHRpb24nKSB7IHRocm93IGU7IH1cblxuICAgICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2shIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdGhhdCBnb2VzIGFsb25nIHdpdGggdGhpcyBjaGFuZ2UgaW50cm9kdWNlc1xuICAgICAgICAvLyBhIG5ldyAnc3NtOkdldFBhcmFtZXRlcicgcGVybWlzc2lvbiwgYnV0IHdoZW4gcnVuIHVzaW5nIHRoZSBwcmV2aW91cyBib290c3RyYXAgdGVtcGxhdGUgd2VcbiAgICAgICAgLy8gd29uJ3QgaGF2ZSB0aGUgcGVybWlzc2lvbnMgeWV0IHRvIHJlYWQgdGhlIHZlcnNpb24sIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gc2hvdyB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSB0ZWxsaW5nIHRoZSB1c2VyIHRoZXkgbmVlZCB0byB1cGRhdGUhIFdoZW4gd2Ugc2VlIGFuIEFjY2Vzc0RlbmllZEV4Y2VwdGlvbiwgZmFsbFxuICAgICAgICAvLyBiYWNrIHRvIHRoZSB2ZXJzaW9uIHdlIHJlYWQgZnJvbSBTdGFjayBPdXRwdXRzOyBidXQgT05MWSBpZiB0aGUgdmVyc2lvbiB3ZSBkaXNjb3ZlcmVkIHZpYVxuICAgICAgICAvLyBvdXRwdXRzIGlzIGxlZ2l0aW1hdGVseSBhbiBvbGQgdmVyc2lvbi4gSWYgaXQncyBuZXdlciB0aGFuIHRoYXQsIHNvbWV0aGluZyBlbHNlIG11c3QgYmUgYnJva2VuLFxuICAgICAgICAvLyBzbyBsZXQgaXQgZmFpbCBhcyBpdCB3b3VsZCBpZiB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIGZhbGxiYWNrLlxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IEJPT1RTVFJBUF9URU1QTEFURV9WRVJTSU9OX0lOVFJPRFVDSU5HX0dFVFBBUkFNRVRFUikge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKGBDb3VsZCBub3QgcmVhZCBTU00gcGFyYW1ldGVyICR7c3NtUGFyYW1ldGVyTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggb24gcHVycG9zZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBlY3RlZFZlcnNpb24gPiB2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGZvdW5kICcke3ZlcnNpb259Jy4gUGxlYXNlIHJ1biAnY2RrIGJvb3RzdHJhcCcuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW4gRUNSIHJlcG9zaXRvcnkgZm9yIHVwbG9hZGluZyB0byB1c2luZyBEb2NrZXJcbiAgICpcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz4ge1xuICAgIGlmICghdGhpcy5zZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbGtpdEluZm8gbmVlZHMgdG8gaGF2ZSBiZWVuIGluaXRpYWxpemVkIHdpdGggYW4gc2RrIHRvIGNhbGwgcHJlcGFyZUVjclJlcG9zaXRvcnknKTtcbiAgICB9XG4gICAgY29uc3QgZWNyID0gdGhpcy5zZGsuZWNyKCk7XG5cbiAgICAvLyBjaGVjayBpZiByZXBvIGFscmVhZHkgZXhpc3RzXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY2hlY2tpbmcgaWYgRUNSIHJlcG9zaXRvcnkgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlUmVzcG9uc2UgPSBhd2FpdCBlY3IuZGVzY3JpYmVSZXBvc2l0b3JpZXMoeyByZXBvc2l0b3J5TmFtZXM6IFtyZXBvc2l0b3J5TmFtZV0gfSkucHJvbWlzZSgpO1xuICAgICAgY29uc3QgZXhpc3RpbmdSZXBvc2l0b3J5VXJpID0gZGVzY3JpYmVSZXNwb25zZS5yZXBvc2l0b3JpZXMhWzBdPy5yZXBvc2l0b3J5VXJpO1xuICAgICAgaWYgKGV4aXN0aW5nUmVwb3NpdG9yeVVyaSkge1xuICAgICAgICByZXR1cm4geyByZXBvc2l0b3J5VXJpOiBleGlzdGluZ1JlcG9zaXRvcnlVcmkgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSByZXBvICh0YWcgaXQgc28gaXQgd2lsbCBiZSBlYXNpZXIgdG8gZ2FyYmFnZSBjb2xsZWN0IGluIHRoZSBmdXR1cmUpXG4gICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjcmVhdGluZyBFQ1IgcmVwb3NpdG9yeWApO1xuICAgIGNvbnN0IGFzc2V0VGFnID0geyBLZXk6ICdhd3NjZGs6YXNzZXQnLCBWYWx1ZTogJ3RydWUnIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3IuY3JlYXRlUmVwb3NpdG9yeSh7IHJlcG9zaXRvcnlOYW1lLCB0YWdzOiBbYXNzZXRUYWddIH0pLnByb21pc2UoKTtcbiAgICBjb25zdCByZXBvc2l0b3J5VXJpID0gcmVzcG9uc2UucmVwb3NpdG9yeT8ucmVwb3NpdG9yeVVyaTtcbiAgICBpZiAoIXJlcG9zaXRvcnlVcmkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ3JlYXRlUmVwb3NpdG9yeSBkaWQgbm90IHJldHVybiBhIHJlcG9zaXRvcnkgVVJJIGZvciAke3JlcG9zaXRvcnlVcml9YCk7XG4gICAgfVxuXG4gICAgLy8gY29uZmlndXJlIGltYWdlIHNjYW5uaW5nIG9uIHB1c2ggKGhlbHBzIGluIGlkZW50aWZ5aW5nIHNvZnR3YXJlIHZ1bG5lcmFiaWxpdGllcywgbm8gYWRkaXRpb25hbCBjaGFyZ2UpXG4gICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBlbmFibGUgaW1hZ2Ugc2Nhbm5pbmdgKTtcbiAgICBhd2FpdCBlY3IucHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb24oeyByZXBvc2l0b3J5TmFtZSwgaW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb246IHsgc2Nhbk9uUHVzaDogdHJ1ZSB9IH0pLnByb21pc2UoKTtcblxuICAgIHJldHVybiB7IHJlcG9zaXRvcnlVcmkgfTtcbiAgfVxuXG4gIHByaXZhdGUgcmVxdWlyZU91dHB1dChvdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCEob3V0cHV0IGluIHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIENESyB0b29sa2l0IHN0YWNrICgke3RoaXMuYm9vdHN0cmFwU3RhY2suc3RhY2tOYW1lfSkgZG9lcyBub3QgaGF2ZSBhbiBvdXRwdXQgbmFtZWQgJHtvdXRwdXR9LiBVc2UgJ2NkayBib290c3RyYXAnIHRvIGNvcnJlY3QgdGhpcy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tvdXRwdXRdO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGJvb3RzdHJhcCBzdGFjayBjb3VsZCBub3QgYmUgZm91bmRcbiAqXG4gKiBUaGlzIGlzIG5vdCBhbiBlcnJvciBpbiBwcmluY2lwbGUsIFVOVElMIG9uZSBvZiB0aGUgbWVtYmVycyBpcyBjYWxsZWQgdGhhdCByZXF1aXJlc1xuICogdGhlIGJvb3RzdHJhcCBzdGFjayB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgdGhlIGxvb2t1cCBlcnJvciBpcyBzdGlsbCB0aHJvd25cbiAqIGJlbGF0ZWRseS5cbiAqXG4gKiBUaGUgZXJyb3JzIGJlbG93IHNlcnZlIGFzIGEgbGFzdCBzdG9wLWdhcCBtZXNzYWdlLS1ub3JtYWxseSBjYWxsaW5nIGNvZGUgc2hvdWxkIGhhdmVcbiAqIGNoZWNrZWQgYHRvb2xraXQuZm91bmRgIGFuZCBwcm9kdWNlZCBhbiBhcHByb3ByaWF0ZSBlcnJvciBtZXNzYWdlLlxuICovXG5jbGFzcyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Ioc2RrOiBJU0RLLCBwcml2YXRlIHJlYWRvbmx5IGVycm9yTWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoc2RrKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYm9vdHN0cmFwU3RhY2soKTogQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZlcnNpb24oKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCB2YXJpYW50KCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZVZlcnNpb24oZXhwZWN0ZWRWZXJzaW9uOiBudW1iZXIsIHNzbVBhcmFtZXRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChzc21QYXJhbWV0ZXJOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgbGV0IHZlcnNpb246IG51bWJlcjtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9IGF3YWl0IFRvb2xraXRJbmZvLnZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHRoaXMuc2RrLCBzc21QYXJhbWV0ZXJOYW1lLCB0aGlzLnNzbUNhY2hlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnQWNjZXNzRGVuaWVkRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBmYWxsYmFjayEgVGhlIGJvb3RzdHJhcCB0ZW1wbGF0ZSB0aGF0IGdvZXMgYWxvbmcgd2l0aCB0aGlzIGNoYW5nZSBpbnRyb2R1Y2VzXG4gICAgICAvLyBhIG5ldyAnc3NtOkdldFBhcmFtZXRlcicgcGVybWlzc2lvbiwgYnV0IHdoZW4gcnVuIHVzaW5nIGEgcHJldmlvdXMgYm9vdHN0cmFwIHRlbXBsYXRlIHdlXG4gICAgICAvLyB3b24ndCBoYXZlIHRoZSBwZXJtaXNzaW9ucyB5ZXQgdG8gcmVhZCB0aGUgdmVyc2lvbiwgc28gd2Ugd29uJ3QgYmUgYWJsZSB0byBzaG93IHRoZVxuICAgICAgLy8gbWVzc2FnZSB0ZWxsaW5nIHRoZSB1c2VyIHRoZXkgbmVlZCB0byB1cGRhdGUhIFdoZW4gd2Ugc2VlIGFuIEFjY2Vzc0RlbmllZEV4Y2VwdGlvbiwgZmFsbFxuICAgICAgLy8gYmFjayB0byB0aGUgdmVyc2lvbiB3ZSByZWFkIGZyb20gU3RhY2sgT3V0cHV0cy5cbiAgICAgIHdhcm5pbmcoYENvdWxkIG5vdCByZWFkIFNTTSBwYXJhbWV0ZXIgJHtzc21QYXJhbWV0ZXJOYW1lfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGZvdW5kIGFuIG9sZGVyIHZlcnNpb24uIFBsZWFzZSBydW4gJ2NkayBib290c3RyYXAnLmApO1xuICAgIH1cblxuICAgIGlmIChleHBlY3RlZFZlcnNpb24gPiB2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGZvdW5kICcke3ZlcnNpb259Jy4gUGxlYXNlIHJ1biAnY2RrIGJvb3RzdHJhcCcuYCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHByZXBhcmVFY3JSZXBvc2l0b3J5KCk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyUmVwb3NpdG9yeUluZm8ge1xuICByZXBvc2l0b3J5VXJpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyQ3JlZGVudGlhbHMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuIl19